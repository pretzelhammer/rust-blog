# Rust ä¸­å¸¸è§çš„æœ‰å…³ç”Ÿå‘½å‘¨æœŸçš„è¯¯è§£

_2020 å¹´ 5 æœˆ 19 æ—¥ Â· é¢„è®¡é˜…è¯» 30 åˆ†é’Ÿ Â· #rust Â· #ç”Ÿå‘½å‘¨æœŸ_

è¯‘è€…ï¼š[SHJ](https://github.com/Foreverhighness)

**ç›®å½•**
- [å¼•è¨€](#å¼•è¨€)
- [è¯¯è§£](#è¯¯è§£)
    - [1) `T` åªåŒ…å«æ‰€æœ‰æƒç±»å‹](#1-t-åªåŒ…å«æ‰€æœ‰æƒç±»å‹)
    - [2) å¦‚æœ `T: 'static` é‚£ä¹ˆ `T` ç›´åˆ°ç¨‹åºç»“æŸä¸ºæ­¢éƒ½ä¸€å®šæ˜¯æœ‰æ•ˆçš„](#2-å¦‚æœ-t-static-é‚£ä¹ˆ-t-ç›´åˆ°ç¨‹åºç»“æŸä¸ºæ­¢éƒ½ä¸€å®šæ˜¯æœ‰æ•ˆçš„)
    - [3) `&'a T` å’Œ `T: 'a` æ˜¯ä¸€å›äº‹](#3-a-t-å’Œ-t-a-æ˜¯ä¸€å›äº‹)
    - [4) æˆ‘çš„ä»£ç é‡Œä¸å«æ³›å‹ä¹Ÿä¸å«ç”Ÿå‘½å‘¨æœŸæ³¨è§£](#4-æˆ‘çš„ä»£ç é‡Œä¸å«æ³›å‹ä¹Ÿä¸å«ç”Ÿå‘½å‘¨æœŸæ³¨è§£)
    - [5) å¦‚æœç¼–è¯‘é€šè¿‡äº†ï¼Œé‚£ä¹ˆæˆ‘æ ‡æ³¨çš„ç”Ÿå‘½å‘¨æœŸå°±æ˜¯æ­£ç¡®çš„](#5-å¦‚æœç¼–è¯‘é€šè¿‡äº†é‚£ä¹ˆæˆ‘æ ‡æ³¨çš„ç”Ÿå‘½å‘¨æœŸå°±æ˜¯æ­£ç¡®çš„)
    - [6) å·²è£…ç®±çš„ trait å¯¹è±¡ä¸å«ç”Ÿå‘½å‘¨æœŸæ³¨è§£](#6-å·²è£…ç®±çš„-trait-å¯¹è±¡ä¸å«ç”Ÿå‘½å‘¨æœŸæ³¨è§£)
    - [7) ç¼–è¯‘æŠ¥é”™çš„ä¿¡æ¯ä¼šå‘Šè¯‰æˆ‘æ€æ ·ä¿®å¤æˆ‘çš„ç¨‹åº](#7-ç¼–è¯‘æŠ¥é”™çš„ä¿¡æ¯ä¼šå‘Šè¯‰æˆ‘æ€æ ·ä¿®å¤æˆ‘çš„ç¨‹åº)
    - [8) ç”Ÿå‘½å‘¨æœŸå¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€å˜é•¿æˆ–å˜çŸ­](#8-ç”Ÿå‘½å‘¨æœŸå¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€å˜é•¿æˆ–å˜çŸ­)
    - [9) å°†ç‹¬å å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨æ˜¯ safe çš„](#9-å°†ç‹¬å å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨æ˜¯-safe-çš„)
    - [10) å¯¹é—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å’Œå‡½æ•°ä¸€æ ·](#10-å¯¹é—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å’Œå‡½æ•°ä¸€æ ·)
    - [11) `'static` å¼•ç”¨æ€»èƒ½è¢«å¼ºåˆ¶è½¬æ¢ä¸º `'a` å¼•ç”¨](#11-static-å¼•ç”¨æ€»èƒ½è¢«å¼ºåˆ¶è½¬æ¢ä¸º-a-å¼•ç”¨)
- [æ€»ç»“](#æ€»ç»“)
- [è®¨è®º](#è®¨è®º)
- [æ¸©é¦¨æç¤º](#æ¸©é¦¨æç¤º)
- [æ‹“å±•é˜…è¯»](#æ‹“å±•é˜…è¯»)
- [è¯‘è€…æ³¨](#è¯‘è€…æ³¨)



## å¼•è¨€

æˆ‘æ›¾ç»ä¹ŸæŠ±æœ‰ä¸Šè¿°çš„è¿™äº›è¯¯è§£ï¼Œå¹¶ä¸”ç°åœ¨ä»æœ‰è®¸å¤šåˆå­¦è€…æ·±é™·å…¶ä¸­ã€‚æœ¬æ–‡ä¸­æˆ‘ä½¿ç”¨çš„æœ¯è¯­å¯èƒ½å¹¶ä¸é‚£ä¹ˆå®˜æ–¹ï¼Œå› æ­¤ä¸‹é¢åˆ—å‡ºäº†ä¸€ä¸ªè¡¨æ ¼ï¼Œè®°å½•æˆ‘ä½¿ç”¨çš„çŸ­è¯­åŠå…¶æƒ³è¡¨è¾¾çš„å«ä¹‰ã€‚

| çŸ­è¯­ | æ„ä¹‰ |
|-|-|
| `T` | 1) æ‰€æœ‰å¯èƒ½ç±»å‹çš„é›†åˆ _æˆ–_<br>2) ä¸Šè¿°é›†åˆä¸­çš„æŸä¸€ä¸ªå…·ä½“ç±»å‹ |
| æ‰€æœ‰æƒç±»å‹ | æŸäº›éå¼•ç”¨ç±»å‹ï¼Œå…¶è‡ªèº«æ‹¥æœ‰æ‰€æœ‰æƒ ä¾‹å¦‚ `i32`, `String`, `Vec` ç­‰ç­‰ |
| 1) å€Ÿç”¨ç±»å‹ _æˆ–_<br>2) å¼•ç”¨ç±»å‹ | å¼•ç”¨ç±»å‹ï¼Œä¸è€ƒè™‘å¯å˜æ€§ ä¾‹å¦‚ `&i32`, `&mut i32` ç­‰ç­‰ |
| 1) å¯å˜å¼•ç”¨ _æˆ–_<br>2) ç‹¬å å¼•ç”¨ | ç‹¬å å¯å˜å¼•ç”¨, å³ `&mut T` |
| 1) ä¸å¯å˜å¼•ç”¨ _æˆ–_<br>2) å…±äº«å¼•ç”¨ | å¯å…±äº«ä¸å¯å˜å¼•ç”¨, å³ `&T` |



## è¯¯è§£

ç®€å•æ¥è®²ï¼Œä¸€ä¸ªå˜é‡çš„ç”Ÿå‘½å‘¨æœŸæ˜¯æŒ‡ä¸€æ®µæ—¶æœŸï¼Œåœ¨è¿™æ®µæ—¶æœŸå†…ï¼Œè¯¥å˜é‡æ‰€æŒ‡å‘çš„å†…å­˜åœ°å€ä¸­çš„æ•°æ®æ˜¯æœ‰æ•ˆçš„ï¼Œè¿™æ®µæ—¶æœŸæ˜¯ç”±ç¼–è¯‘å™¨é™æ€åˆ†æå¾—å‡ºçš„ï¼Œæœ‰æ•ˆæ€§ç”±ç¼–è¯‘å™¨ä¿è¯ã€‚æ¥ä¸‹æ¥æˆ‘å°†æ¢è®¨è¿™äº›å¸¸è§è¯¯è§£çš„ç»†èŠ‚ã€‚



### 1) `T` åªåŒ…å«æ‰€æœ‰æƒç±»å‹

è¿™æ›´åƒæ˜¯å¯¹æ³›å‹çš„è¯¯è§£è€Œéå¯¹ç”Ÿå‘½å‘¨æœŸçš„è¯¯è§£ï¼Œä½†åœ¨ Rust ä¸­ï¼Œæ³›å‹ä¸ç”Ÿå‘½å‘¨æœŸçš„å…³ç³»æ˜¯å¦‚æ­¤ç´§å¯†ï¼Œä»¥è‡³äºä¸å¯èƒ½åªè®¨è®ºå…¶ä¸­ä¸€ä¸ªè€Œå¿½è§†å¦å¤–ä¸€ä¸ªã€‚

å½“æˆ‘åˆšå¼€å§‹å­¦ä¹  Rust æ—¶ï¼Œæˆ‘çŸ¥é“ `i32`, `&i32`, å’Œ `&mut i32` æ˜¯ä¸åŒçš„ç±»å‹ï¼ŒåŒæ—¶æˆ‘ä¹ŸçŸ¥æ³›å‹ `T` è¡¨ç¤ºæ‰€æœ‰å¯èƒ½ç±»å‹çš„é›†åˆã€‚ç„¶è€Œï¼Œå°½ç®¡èƒ½åˆ†åˆ«ç†è§£è¿™ä¸¤ä¸ªæ¦‚å¿µï¼Œä½†æˆ‘å´æ²¡èƒ½å°†äºŒè€…ç»“åˆèµ·æ¥ã€‚åœ¨å½“æ—¶æˆ‘è¿™ä½ Rust åˆå­¦è€…çš„çœ¼é‡Œï¼Œæ³›å‹æ˜¯è¿™æ ·è¿ä½œçš„ï¼š

| | | | |
|-|-|-|-|
| **ç±»å‹** | `T` | `&T` | `&mut T` |
| **ä¾‹å­** | `i32` | `&i32` | `&mut i32` |

å…¶ä¸­ `T` åŒ…å…¨ä½“æ‰€æœ‰æƒç±»å‹ï¼›`&T` åŒ…æ‹¬å…¨ä½“ä¸å¯å˜å¼•ç”¨ï¼›`&mut T` åŒ…æ‹¬å…¨ä½“å¯å˜å¼•ç”¨ï¼›`T`, `&T`, å’Œ `&mut T` æ˜¯ä¸ç›¸äº¤çš„æœ‰é™é›†ã€‚ç®€æ´æ˜äº†ï¼Œç¬¦åˆç›´è§‰ï¼Œå´å®Œå…¨é”™è¯¯ã€‚äº‹å®ä¸Šæ³›å‹æ˜¯è¿™æ ·è¿ä½œçš„ï¼š

| | | | |
|-|-|-|-|
| **ç±»å‹** | `T` | `&T` | `&mut T` |
| **ä¾‹å­** | `i32`, `&i32`, `&mut i32`, `&&i32`, `&mut &mut i32`, ... | `&i32`, `&&i32`, `&&mut i32`, ... | `&mut i32`, `&mut &mut i32`, `&mut &i32`, ... |

`T`, `&T`, å’Œ `&mut T` éƒ½æ˜¯æ— é™é›†ï¼Œå› ä¸ºä½ å¯ä»¥å€Ÿç”¨ä¸€ä¸ªç±»å‹æ— é™æ¬¡ã€‚`T` æ˜¯ `&T` å’Œ `&mut T` çš„è¶…é›†ã€‚`&T` å’Œ `&mut T` æ˜¯ä¸ç›¸äº¤çš„é›†åˆ. ä¸‹é¢æœ‰ä¸€äº›ä¾‹å­æ¥éªŒè¯è¿™äº›æ¦‚å¿µï¼š

```rust
trait Trait {}

impl<T> Trait for T {}

impl<T> Trait for &T {} // ç¼–è¯‘é”™è¯¯

impl<T> Trait for &mut T {} // ç¼–è¯‘é”™è¯¯
```

ä¸Šè¿°ä»£ç ä¸èƒ½ç¼–è¯‘é€šè¿‡ï¼š

```rust
error[E0119]: conflicting implementations of trait `Trait` for type `&_`:
 --> src/lib.rs:5:1
  |
3 | impl<T> Trait for T {}
  | ------------------- first implementation here
4 |
5 | impl<T> Trait for &T {}
  | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&_`

error[E0119]: conflicting implementations of trait `Trait` for type `&mut _`:
 --> src/lib.rs:7:1
  |
3 | impl<T> Trait for T {}
  | ------------------- first implementation here
...
7 | impl<T> Trait for &mut T {}
  | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&mut _`
```

ç¼–è¯‘å™¨ä¸å…è®¸æˆ‘ä»¬ä¸º `&T` å’Œ `&mut T` å®ç° `Trait`ï¼Œå› ä¸ºè¿™ä¸æˆ‘ä»¬ä¸º `T` å®ç°çš„ `Trait` å‘ç”Ÿäº†å†²çªï¼Œè€Œ `T` å·²ç»åŒ…æ‹¬äº† `&T` å’Œ `&mut T`. å› ä¸º `&T` å’Œ `&mut T` æ˜¯ä¸ç›¸äº¤çš„ï¼Œæ‰€ä»¥ä¸‹é¢çš„ä»£ç å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼š

```rust
trait Trait {}

impl<T> Trait for &T {} // ç¼–è¯‘é€šè¿‡

impl<T> Trait for &mut T {} // ç¼–è¯‘é€šè¿‡
```

**å…³é”®ç‚¹å›é¡¾**
- `T` æ˜¯ `&T` å’Œ `&mut T` çš„è¶…é›†
- `&T` å’Œ `&mut T` æ˜¯ä¸ç›¸äº¤çš„é›†åˆ


### 2) å¦‚æœ `T: 'static` é‚£ä¹ˆ `T` ç›´åˆ°ç¨‹åºç»“æŸä¸ºæ­¢éƒ½ä¸€å®šæ˜¯æœ‰æ•ˆçš„

**é”™è¯¯çš„æ¨è®º**
- `T: 'static` åº”è¯¥è§†ä¸º _â€œ`T` æœ‰ç€ `'static`ç”Ÿå‘½å‘¨æœŸâ€_
- `&'static T` å’Œ `T: 'static` æ˜¯ä¸€å›äº‹
- è‹¥ `T: 'static` åˆ™ `T` ä¸€å®šæ˜¯ä¸å¯å˜çš„
- è‹¥ `T: 'static` åˆ™ `T` åªèƒ½åœ¨ç¼–è¯‘æœŸåˆ›å»º

è®©å¤§å¤šæ•° Rust åˆå­¦è€…ç¬¬ä¸€æ¬¡æ¥è§¦ `'static` ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„ä»£ç ç¤ºä¾‹å¤§æ¦‚æ˜¯è¿™æ ·çš„ï¼š

```rust
fn main() {
    let str_literal: &'static str = "å­—ç¬¦ä¸²å­—é¢é‡";
}
```

ä»–ä»¬è¢«å‘ŠçŸ¥è¯´ `"å­—ç¬¦ä¸²å­—é¢é‡"` æ˜¯è¢«ç¡¬ç¼–ç åˆ°ç¼–è¯‘å‡ºæ¥çš„äºŒè¿›åˆ¶æ–‡ä»¶å½“ä¸­å»çš„ï¼Œå¹¶åœ¨è¿è¡Œæ—¶è¢«åŠ è½½åˆ°åªè¯»å†…å­˜ä¸­ï¼Œæ‰€ä»¥å®ƒä¸å¯å˜ä¸”åœ¨ç¨‹åºçš„æ•´ä¸ªè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆï¼Œè¿™ä¹Ÿä½¿å…¶ç”Ÿå‘½å‘¨æœŸä¸º `'static`. åœ¨äº†è§£åˆ° Rust ä½¿ç”¨ `static` æ¥å®šä¹‰é™æ€å˜é‡è¿™ä¸€è¯­æ³•åï¼Œè¿™ä¸€è§‚ç‚¹è¿˜ä¼šè¢«è¿›ä¸€æ­¥åŠ å¼ºã€‚

```rust
static BYTES: [u8; 3] = [1, 2, 3];
static mut MUT_BYTES: [u8; 3] = [1, 2, 3];

fn main() {
   MUT_BYTES[0] = 99; // ç¼–è¯‘é”™è¯¯ï¼Œä¿®æ”¹é™æ€å˜é‡æ˜¯ unsafe çš„

    unsafe {
        MUT_BYTES[0] = 99;
        assert_eq!(99, MUT_BYTES[0]);
    }
}
```

å…³äºé™æ€å˜é‡
- å®ƒä»¬åªèƒ½åœ¨ç¼–è¯‘æœŸåˆ›å»º
- å®ƒä»¬åº”å½“æ˜¯ä¸å¯å˜çš„ï¼Œä¿®æ”¹é™æ€å˜é‡æ˜¯ unsafe çš„
- å®ƒä»¬åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´æœ‰æ•ˆ

é™æ€å˜é‡çš„é»˜è®¤ç”Ÿå‘½å‘¨æœŸå¾ˆæœ‰å¯èƒ½æ˜¯ `'static` , å¯¹å§ï¼Ÿæ‰€ä»¥å¯ä»¥åˆç†æ¨æµ‹ `'static` ç”Ÿå‘½å‘¨æœŸä¹Ÿè¦éµå¾ªåŒæ ·çš„è§„åˆ™ï¼Œå¯¹å§ï¼Ÿ

ç¡®å®ï¼Œä½† _å¸¦æœ‰_ `'static` ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„ç±»å‹å’Œä¸€ä¸ªè¢« `'static` _çº¦æŸ_ çš„ç±»å‹æ˜¯ä¸ä¸€æ ·çš„ã€‚åè€…å¯ä»¥äºè¿è¡Œæ—¶è¢«åŠ¨æ€åˆ†é…ï¼Œèƒ½è¢«å®‰å…¨è‡ªç”±åœ°ä¿®æ”¹ï¼Œä¹Ÿå¯ä»¥è¢« drop, è¿˜èƒ½å­˜æ´»ä»»æ„çš„æ—¶é•¿ã€‚

åŒºåˆ† `&'static T` å’Œ `T: 'static` æ˜¯éå¸¸é‡è¦çš„ä¸€ç‚¹ã€‚

`&'static T` æ˜¯ä¸€ä¸ªæŒ‡å‘ `T` çš„ä¸å¯å˜å¼•ç”¨ï¼Œå…¶ä¸­ `T` å¯ä»¥è¢«å®‰å…¨åœ°æ— æœŸé™åœ°æŒæœ‰ï¼Œç”šè‡³å¯ä»¥ç›´åˆ°ç¨‹åºç»“æŸã€‚è¿™åªæœ‰åœ¨ `T` è‡ªèº«ä¸å¯å˜ä¸”ä¿è¯ _åœ¨å¼•ç”¨åˆ›å»ºå_ ä¸ä¼šè¢« move æ—¶æ‰æœ‰å¯èƒ½ã€‚`T` å¹¶ä¸éœ€è¦åœ¨ç¼–è¯‘æ—¶åˆ›å»ºã€‚ æˆ‘ä»¬å¯ä»¥ä»¥å†…å­˜æ³„æ¼ä¸ºä»£ä»·ï¼Œåœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ›å»ºéšæœºæ•°æ®ï¼Œå¹¶è¿”å›å…¶ `'static` å¼•ç”¨ï¼Œæ¯”å¦‚ï¼š

```rust
use rand;

// åœ¨è¿è¡Œæ—¶ç”Ÿæˆéšæœº &'static str
fn rand_str_generator() -> &'static str {
    let rand_string = rand::random::<u64>().to_string();
    Box::leak(rand_string.into_boxed_str())
}
```

`T: 'static` æ˜¯æŒ‡ `T` å¯ä»¥è¢«å®‰å…¨åœ°æ— æœŸé™åœ°æŒæœ‰ï¼Œç”šè‡³å¯ä»¥ç›´åˆ°ç¨‹åºç»“æŸã€‚ `T: 'static` åœ¨åŒ…æ‹¬äº†å…¨éƒ¨ `&'static T` çš„åŒæ—¶ï¼Œè¿˜åŒ…æ‹¬äº†å…¨éƒ¨æ‰€æœ‰æƒç±»å‹ï¼Œ æ¯”å¦‚ `String`, `Vec` ç­‰ç­‰ã€‚ æ•°æ®çš„æ‰€æœ‰è€…ä¿è¯ï¼Œåªè¦è‡ªèº«è¿˜æŒæœ‰æ•°æ®çš„æ‰€æœ‰æƒï¼Œæ•°æ®å°±ä¸ä¼šå¤±æ•ˆï¼Œå› æ­¤æ‰€æœ‰è€…èƒ½å¤Ÿå®‰å…¨åœ°æ— æœŸé™åœ°æŒæœ‰å…¶æ•°æ®ï¼Œç”šè‡³å¯ä»¥ç›´åˆ°ç¨‹åºç»“æŸã€‚`T: 'static` åº”å½“è§†ä¸º _â€œ`T` æ»¡è¶³ `'static` ç”Ÿå‘½å‘¨æœŸçº¦æŸâ€_ è€Œé _â€œ`T` æœ‰ç€ `'static` ç”Ÿå‘½å‘¨æœŸâ€_ã€‚ ä¸€ä¸ªç¨‹åºå¯ä»¥å¸®åŠ©é˜è¿°è¿™äº›æ¦‚å¿µï¼š

```rust
use rand;

fn drop_static<T: 'static>(t: T) {
    std::mem::drop(t);
}

fn main() {
    let mut strings: Vec<String> = Vec::new();
    for _ in 0..10 {
        if rand::random() {
            // æ‰€æœ‰å­—ç¬¦ä¸²éƒ½æ˜¯éšæœºç”Ÿæˆçš„
            // å¹¶ä¸”åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†é…
            let string = rand::random::<u64>().to_string();
            strings.push(string);
        }
    }

    // è¿™äº›å­—ç¬¦ä¸²æ˜¯æ‰€æœ‰æƒç±»å‹ï¼Œæ‰€ä»¥ä»–ä»¬æ»¡è¶³ 'static ç”Ÿå‘½å‘¨æœŸçº¦æŸ
    for mut string in strings {
        // è¿™äº›å­—ç¬¦ä¸²æ˜¯å¯å˜çš„
        string.push_str("a mutation");
        // è¿™äº›å­—ç¬¦ä¸²éƒ½å¯ä»¥è¢« drop
        drop_static(string); // ç¼–è¯‘é€šè¿‡
    }

    // è¿™äº›å­—ç¬¦ä¸²åœ¨ç¨‹åºç»“æŸä¹‹å‰å°±å·²ç»å…¨éƒ¨å¤±æ•ˆäº†
    println!("i am the end of the program");
}
```

**å…³é”®ç‚¹å›é¡¾**
- `T: 'static` åº”å½“è§†ä¸º _â€œ`T` æ»¡è¶³ `'static` ç”Ÿå‘½å‘¨æœŸçº¦æŸâ€_
- è‹¥ `T: 'static` åˆ™ `T` å¯ä»¥æ˜¯ä¸€ä¸ªæœ‰ `'static` ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ç±»å‹ _æˆ–_ æ˜¯ä¸€ä¸ªæ‰€æœ‰æƒç±»å‹
- å› ä¸º `T: 'static` åŒ…æ‹¬äº†æ‰€æœ‰æƒç±»å‹ï¼Œæ‰€ä»¥ `T`
  - å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†é…
  - ä¸éœ€è¦åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆ
  - å¯ä»¥å®‰å…¨ï¼Œè‡ªç”±åœ°ä¿®æ”¹
  - å¯ä»¥åœ¨è¿è¡Œæ—¶è¢«åŠ¨æ€çš„ drop
  - å¯ä»¥æœ‰ä¸åŒé•¿åº¦çš„ç”Ÿå‘½å‘¨æœŸ



### 3) `&'a T` å’Œ `T: 'a` æ˜¯ä¸€å›äº‹

è¿™ä¸ªè¯¯è§£æ˜¯å‰ä¸€ä¸ªè¯¯è§£çš„æ³›åŒ–ç‰ˆæœ¬ã€‚

`&'a T` è¦æ±‚å¹¶éšå«äº† `T: 'a` ï¼Œå› ä¸ºå¦‚æœ `T` æœ¬èº«ä¸èƒ½åœ¨ `'a` èŒƒå›´å†…ä¿è¯æœ‰æ•ˆï¼Œé‚£ä¹ˆå…¶å¼•ç”¨ä¹Ÿä¸èƒ½åœ¨ `'a` èŒƒå›´å†…ä¿è¯æœ‰æ•ˆã€‚ä¾‹å¦‚ï¼ŒRust ç¼–è¯‘å™¨ä¸ä¼šè¿è¡Œæ„é€ ä¸€ä¸ª `&'static Ref<'a, T>`ï¼Œå› ä¸ºå¦‚æœ `Ref` åªåœ¨ `'a` èŒƒå›´å†…æœ‰æ•ˆï¼Œæˆ‘ä»¬å°±ä¸èƒ½ç»™å®ƒ `'static` ç”Ÿå‘½å‘¨æœŸã€‚

`T: 'a` åŒ…æ‹¬äº†å…¨ä½“ `&'a T`ï¼Œä½†åä¹‹ä¸æˆç«‹ã€‚

```rust
// åªæ¥å—å¸¦æœ‰ 'a ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„å¼•ç”¨ç±»å‹
fn t_ref<'a, T: 'a>(t: &'a T) {}

// æ¥å—æ»¡è¶³ 'a ç”Ÿå‘½å‘¨æœŸçº¦æŸçš„ä»»ä½•ç±»å‹
fn t_bound<'a, T: 'a>(t: T) {}

// å†…éƒ¨å«æœ‰å¼•ç”¨çš„æ‰€æœ‰æƒç±»å‹
struct Ref<'a, T: 'a>(&'a T);

fn main() {
    let string = String::from("string");

    t_bound(&string); // ç¼–è¯‘é€šè¿‡
    t_bound(Ref(&string)); // ç¼–è¯‘é€šè¿‡
    t_bound(&Ref(&string)); // ç¼–è¯‘é€šè¿‡

    t_ref(&string); // ç¼–è¯‘é€šè¿‡
    t_ref(Ref(&string)); // ç¼–è¯‘å¤±è´¥ï¼ŒæœŸæœ›å¾—åˆ°å¼•ç”¨ï¼Œå®é™…å¾—åˆ° struct
    t_ref(&Ref(&string)); // ç¼–è¯‘é€šè¿‡

    // æ»¡è¶³ 'static çº¦æŸçš„å­—ç¬¦ä¸²å˜é‡å¯ä»¥è½¬æ¢ä¸º 'a çº¦æŸ
    t_bound(string); // ç¼–è¯‘é€šè¿‡
}
```

**å…³é”®ç‚¹å›é¡¾**
- `T: 'a` æ¯” `&'a T` æ›´æ³›åŒ–ï¼Œæ›´çµæ´»
- `T: 'a` æ¥å—æ‰€æœ‰æƒç±»å‹ï¼Œå†…éƒ¨å«æœ‰å¼•ç”¨çš„æ‰€æœ‰æƒç±»å‹ï¼Œå’Œå¼•ç”¨
- `&'a T` åªæ¥å—å¼•ç”¨
- è‹¥ `T: 'static` åˆ™ `T: 'a` å› ä¸ºå¯¹äºæ‰€æœ‰ `'a` éƒ½æœ‰ `'static` >= `'a`



### 4) æˆ‘çš„ä»£ç é‡Œä¸å«æ³›å‹ä¹Ÿä¸å«ç”Ÿå‘½å‘¨æœŸæ³¨è§£

**é”™è¯¯çš„æ¨è®º**
- é¿å…ä½¿ç”¨æ³›å‹å’Œç”Ÿå‘½å‘¨æœŸæ³¨è§£æ˜¯å¯èƒ½çš„

è¿™ä¸ªè®©äººçˆ½åˆ°çš„è¯¯è§£ä¹‹æ‰€ä»¥èƒ½å­˜åœ¨ï¼Œè¦å¾—ç›Šäº Rust çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼Œè¿™ä¸ªè§„åˆ™èƒ½å…è®¸ä½ åœ¨å‡½æ•°å®šä¹‰ä»¥åŠ `impl` å—ä¸­çœç•¥æ‰æ˜¾å¼çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œè€Œç”±å€Ÿç”¨æ£€æŸ¥å™¨æ¥æ ¹æ®ä»¥ä¸‹è§„åˆ™å¯¹ç”Ÿå‘½å‘¨æœŸè¿›è¡Œéšå¼æ¨å¯¼ã€‚
- ç¬¬ä¸€æ¡è§„åˆ™æ˜¯æ¯ä¸€ä¸ªæ˜¯å¼•ç”¨çš„å‚æ•°éƒ½æœ‰å®ƒè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°
- ç¬¬äºŒæ¡è§„åˆ™æ˜¯å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆå®ƒè¢«èµ‹äºˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°
- ç¬¬ä¸‰æ¡è§„åˆ™æ˜¯å¦‚æœæ˜¯æœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°çš„æ–¹æ³•ï¼Œè€Œå…¶ä¸­ä¸€ä¸ªå‚æ•°æ˜¯ `&self` æˆ– `&mut self`, é‚£ä¹ˆæ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°è¢«èµ‹äºˆ `self` çš„ç”Ÿå‘½å‘¨æœŸã€‚
- å…¶ä»–æƒ…å†µä¸‹ï¼Œç”Ÿå‘½å‘¨æœŸå¿…é¡»æœ‰æ˜ç¡®çš„æ³¨è§£

è¿™é‡Œæœ‰ä¸å°‘å€¼å¾—è®²çš„ä¸œè¥¿ï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸€äº›ä¾‹å­ï¼š

```rust
// å±•å¼€å‰
fn print(s: &str);

// å±•å¼€å
fn print<'a>(s: &'a str);

// å±•å¼€å‰
fn trim(s: &str) -> &str;

// å±•å¼€å
fn trim<'a>(s: &'a str) -> &'a str;

// éæ³•ï¼Œæ²¡æœ‰è¾“å…¥ï¼Œä¸èƒ½ç¡®å®šè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ
fn get_str() -> &str;

// æ˜¾å¼æ ‡æ³¨çš„æ–¹æ¡ˆ
fn get_str<'a>() -> &'a str; // æ³›å‹ç‰ˆæœ¬
fn get_str() -> &'static str; // 'static ç‰ˆæœ¬

// éæ³•ï¼Œå¤šä¸ªè¾“å…¥ï¼Œä¸èƒ½ç¡®å®šè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ
fn overlap(s: &str, t: &str) -> &str;

// æ˜¾å¼æ ‡æ³¨ï¼ˆä½†ä»æœ‰éƒ¨åˆ†æ ‡æ³¨è¢«çœç•¥ï¼‰çš„æ–¹æ¡ˆ
fn overlap<'a>(s: &'a str, t: &str) -> &'a str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸é•¿äº s
fn overlap<'a>(s: &str, t: &'a str) -> &'a str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸é•¿äº t
fn overlap<'a>(s: &'a str, t: &'a str) -> &'a str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸é•¿äº s ä¸”ä¸é•¿äº t
fn overlap(s: &str, t: &str) -> &'static str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸå¯ä»¥é•¿äº s æˆ–è€… t
fn overlap<'a>(s: &str, t: &str) -> &'a str; // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸è¾“å…¥æ— å…³

// å±•å¼€å
fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'a str;
fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'b str;
fn overlap<'a>(s: &'a str, t: &'a str) -> &'a str;
fn overlap<'a, 'b>(s: &'a str, t: &'b str) -> &'static str;
fn overlap<'a, 'b, 'c>(s: &'a str, t: &'b str) -> &'c str;

// å±•å¼€å‰
fn compare(&self, s: &str) -> &str;

// å±•å¼€å
fn compare<'a, 'b>(&'a self, &'b str) -> &'a str;
```

å¦‚æœä½ å†™è¿‡
- ç»“æ„ä½“æ–¹æ³•
- æ¥æ”¶å‚æ•°ä¸­æœ‰å¼•ç”¨çš„å‡½æ•°
- è¿”å›å€¼æ˜¯å¼•ç”¨çš„å‡½æ•°
- æ³›å‹å‡½æ•°
- trait object(åé¢å°†è®¨è®º)
- é—­åŒ…ï¼ˆåé¢å°†è®¨è®ºï¼‰

é‚£ä¹ˆå¯¹äºä¸Šé¢è¿™äº›ï¼Œä½ çš„ä»£ç ä¸­éƒ½æœ‰è¢«çœç•¥çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚

**å…³é”®ç‚¹å›é¡¾**
- å‡ ä¹æ‰€æœ‰çš„ Rust ä»£ç éƒ½æ˜¯æ³›å‹ä»£ç ï¼Œå¹¶ä¸”åˆ°å¤„éƒ½å¸¦æœ‰è¢«çœç•¥æ‰çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸæ³¨è§£



### 5) å¦‚æœç¼–è¯‘é€šè¿‡äº†ï¼Œé‚£ä¹ˆæˆ‘æ ‡æ³¨çš„ç”Ÿå‘½å‘¨æœŸå°±æ˜¯æ­£ç¡®çš„

**é”™è¯¯çš„æ¨è®º**
- Rust å¯¹å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™æ€»æ˜¯å¯¹çš„
- Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨æ€»æ˜¯æ­£ç¡®çš„ï¼Œæ— è®ºæ˜¯æŠ€å·§ä¸Šè¿˜æ˜¯è¯­ä¹‰ä¸Š
- Rust æ¯”æˆ‘æ›´æ‡‚æˆ‘ç¨‹åºçš„è¯­ä¹‰

è®©ä¸€ä¸ª Rust ç¨‹åºé€šè¿‡ç¼–è¯‘ä½†è¯­ä¹‰ä¸Šä¸æ­£ç¡®æ˜¯æœ‰å¯èƒ½çš„ã€‚æ¥çœ‹çœ‹è¿™ä¸ªä¾‹å­ï¼š

```rust
struct ByteIter<'a> {
    remainder: &'a [u8]
}

impl<'a> ByteIter<'a> {
    fn next(&mut self) -> Option<&u8> {
        if self.remainder.is_empty() {
            None
        } else {
            let byte = &self.remainder[0];
            self.remainder = &self.remainder[1..];
            Some(byte)
        }
    }
}

fn main() {
    let mut bytes = ByteIter { remainder: b"1" };
    assert_eq!(Some(&b'1'), bytes.next());
    assert_eq!(None, bytes.next());
}
```

`ByteIter` æ˜¯ä¸€ä¸ª byte åˆ‡ç‰‡ä¸Šçš„è¿­ä»£å™¨ï¼Œç®€æ´èµ·è§ï¼Œæˆ‘è¿™é‡Œçœç•¥äº† Iterator trait çš„å…·ä½“å®ç°ã€‚è¿™çœ‹èµ·æ¥æ²¡ä»€ä¹ˆé—®é¢˜ï¼Œä½†å¦‚æœæˆ‘ä»¬æƒ³åŒæ—¶æ£€æŸ¥å¤šä¸ª byte å‘¢ï¼Ÿ

```rust
fn main() {
    let mut bytes = ByteIter { remainder: b"1123" };
    let byte_1 = bytes.next();
    let byte_2 = bytes.next();
    if byte_1 == byte_2 {
        // ä¸€äº›ä»£ç 
    }
}
```

ç¼–è¯‘é”™è¯¯ï¼š

```rust
error[E0499]: cannot borrow `bytes` as mutable more than once at a time
  --> src/main.rs:20:18
   |
19 |     let byte_1 = bytes.next();
   |                  ----- first mutable borrow occurs here
20 |     let byte_2 = bytes.next();
   |                  ^^^^^ second mutable borrow occurs here
21 |     if byte_1 == byte_2 {
   |        ------ first borrow later used here
```

å¦‚æœä½ è¯´å¯ä»¥é€šè¿‡é€ byte æ‹·è´æ¥é¿å…ç¼–è¯‘é”™è¯¯ï¼Œé‚£ä¹ˆç¡®å®ã€‚å½“è¿­ä»£ä¸€ä¸ª byte æ•°ç»„ä¸Šæ—¶ï¼Œæˆ‘ä»¬çš„ç¡®å¯ä»¥é€šè¿‡æ‹·è´æ¯ä¸ª byte æ¥è¾¾æˆç›®çš„ã€‚ä½†æ˜¯å¦‚æœæˆ‘æƒ³è¦å°†  `ByteIter` æ”¹å†™æˆä¸€ä¸ªæ³›å‹çš„åˆ‡ç‰‡è¿­ä»£å™¨ï¼Œä½¿å¾—æˆ‘ä»¬èƒ½å¤Ÿå¯¹ä»»æ„ `&'a [T]` è¿›è¡Œè¿­ä»£ï¼Œè€Œæ­¤æ—¶å¦‚æœæœ‰ä¸€ä¸ª `T`ï¼Œå…¶ copy å’Œ clone çš„ä»£ä»·ååˆ†æ˜‚è´µï¼Œé‚£ä¹ˆæˆ‘ä»¬è¯¥æ€ä¹ˆé¿å…è¿™ç§æ˜‚è´µçš„æ“ä½œå‘¢ï¼Ÿå“¦ï¼Œæˆ‘æƒ³æˆ‘ä»¬ä¸èƒ½ï¼Œæ¯•ç«Ÿä»£ç éƒ½é€šè¿‡ç¼–è¯‘äº†ï¼Œé‚£ä¹ˆç”Ÿå‘½å‘¨æœŸæ³¨è§£è‚¯å®šä¹Ÿæ˜¯å¯¹çš„ï¼Œå¯¹å§ï¼Ÿ

é”™ï¼Œäº‹å®ä¸Šç°æœ‰çš„ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ bug çš„æºå¤´ï¼è¿™ä¸ªé”™è¯¯çš„ç”Ÿå‘½å‘¨æœŸè¢«çœç•¥æ‰äº†ä»¥è‡³äºéš¾ä»¥è¢«å‘ç°ã€‚ç°åœ¨è®©æˆ‘ä»¬å±•å¼€è¿™äº›è¢«çœç•¥æ‰çš„ç”Ÿå‘½å‘¨æœŸæ¥æš´éœ²å‡ºè¿™ä¸ªé—®é¢˜ã€‚

```rust
struct ByteIter<'a> {
    remainder: &'a [u8]
}

impl<'a> ByteIter<'a> {
    fn next<'b>(&'b mut self) -> Option<&'b u8> {
        if self.remainder.is_empty() {
            None
        } else {
            let byte = &self.remainder[0];
            self.remainder = &self.remainder[1..];
            Some(byte)
        }
    }
}
```

æ„Ÿè§‰å¥½åƒæ²¡å•¥ç”¨ï¼Œæˆ‘è¿˜æ˜¯æä¸æ¸…æ¥šé—®é¢˜å‡ºåœ¨å“ªã€‚è¿™é‡Œæœ‰ä¸ª Rust ä¸“å®¶æ‰çŸ¥é“çš„å°æŠ€å·§ï¼šç»™ä½ çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£èµ·ä¸€ä¸ªæ›´æœ‰å«ä¹‰çš„åå­—ï¼Œè®©æˆ‘ä»¬è¯•ä¸€ä¸‹ï¼š

```rust
struct ByteIter<'remainder> {
    remainder: &'remainder [u8]
}

impl<'remainder> ByteIter<'remainder> {
    fn next<'mut_self>(&'mut_self mut self) -> Option<&'mut_self u8> {
        if self.remainder.is_empty() {
            None
        } else {
            let byte = &self.remainder[0];
            self.remainder = &self.remainder[1..];
            Some(byte)
        }
    }
}
```

æ¯ä¸ªè¿”å›çš„ byte éƒ½è¢«æ ‡æ³¨ä¸º `'mut_self`, ä½†æ˜¯æ˜¾ç„¶è¿™äº› byte éƒ½æºäº `'remainder`! è®©æˆ‘ä»¬æ¥ä¿®å¤ä¸€ä¸‹è¿™æ®µä»£ç ã€‚

```rust
struct ByteIter<'remainder> {
    remainder: &'remainder [u8]
}

impl<'remainder> ByteIter<'remainder> {
    fn next(&mut self) -> Option<&'remainder u8> {
        if self.remainder.is_empty() {
            None
        } else {
            let byte = &self.remainder[0];
            self.remainder = &self.remainder[1..];
            Some(byte)
        }
    }
}

fn main() {
    let mut bytes = ByteIter { remainder: b"1123" };
    let byte_1 = bytes.next();
    let byte_2 = bytes.next();
    std::mem::drop(bytes); // æˆ‘ä»¬ç°åœ¨ç”šè‡³å¯ä»¥æŠŠè¿™ä¸ªè¿­ä»£å™¨ç»™ drop æ‰ï¼
    if byte_1 == byte_2 { // ç¼–è¯‘é€šè¿‡
        // ä¸€äº›ä»£ç 
    }
}
```

ç°åœ¨æˆ‘ä»¬å†å›è¿‡å¤´æ¥çœ‹çœ‹æˆ‘ä»¬ä¸Šä¸€ç‰ˆçš„å®ç°ï¼Œå°±èƒ½çœ‹å‡ºå®ƒæ˜¯é”™çš„äº†ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆ Rust ä¼šç¼–è¯‘é€šè¿‡å‘¢ï¼Ÿç­”æ¡ˆå¾ˆç®€å•ï¼šå› ä¸ºè¿™æ˜¯å†…å­˜å®‰å…¨çš„ã€‚

Rust å€Ÿç”¨æ£€æŸ¥å™¨å¯¹ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„è¦æ±‚åªåˆ°èƒ½é™æ€éªŒè¯ç¨‹åºçš„å†…å­˜å®‰å…¨ä¸ºæ­¢ã€‚å³ä¾¿ç”Ÿå‘½å‘¨æœŸæ³¨è§£æœ‰è¯­ä¹‰ä¸Šçš„é”™è¯¯ï¼ŒRust ä¹Ÿèƒ½è®©ç¨‹åºç¼–è¯‘é€šè¿‡ï¼Œå“ªæ€•è¿™æ ·åšä¸ºç¨‹åºå¸¦æ¥ä¸å¿…è¦çš„é™åˆ¶ã€‚

è¿™å„¿æœ‰ä¸€ä¸ªå’Œä¹‹å‰ç›¸åçš„ä¾‹å­ï¼šåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒRust ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™æ ‡æ³¨çš„ç”Ÿå‘½å‘¨æœŸæ˜¯è¯­ä¹‰æ­£ç¡®çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å´åœ¨æ— æ„é—´ä½¿ç”¨äº†ä¸å¿…è¦çš„æ˜¾å¼æ³¨è§£ï¼Œå¯¼è‡´å†™å‡ºäº†ä¸€ä¸ªé™åˆ¶æå…¶ä¸¥æ ¼çš„æ–¹æ³•ã€‚

```rust
#[derive(Debug)]
struct NumRef<'a>(&'a i32);

impl<'a> NumRef<'a> {
    // æˆ‘å®šä¹‰çš„æ³›å‹ç»“æ„ä½“ä»¥ 'a ä¸ºå‚æ•°ï¼Œè¿™æ„å‘³ç€æˆ‘ä¹Ÿéœ€è¦ç»™æ–¹æ³•çš„å‚æ•°
    // æ ‡æ³¨ä¸º 'a ç”Ÿå‘½å‘¨æœŸï¼Œå¯¹å—ï¼Ÿï¼ˆç­”æ¡ˆï¼šé”™ï¼‰
    fn some_method(&'a mut self) {}
}

fn main() {
    let mut num_ref = NumRef(&5);
    num_ref.some_method(); // å¯å˜å€Ÿç”¨ num_ref ç›´è‡³å…¶ç”Ÿå‘½å‘¨æœŸç»“æŸ
    num_ref.some_method(); // ç¼–è¯‘é”™è¯¯
    println!("{:?}", num_ref); // åŒæ ·ç¼–è¯‘é”™è¯¯
}
```

å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªå¸¦ `'a` æ³›å‹å‚æ•°çš„ç»“æ„ä½“ï¼Œæˆ‘ä»¬å‡ ä¹ä¸å¯èƒ½å»å†™ä¸€ä¸ªå¸¦ `&'a mut self` å‚æ•°çš„æ–¹æ³•ã€‚å› ä¸ºè¿™ç›¸å½“äºå‘Šè¯‰ Rust â€œè¿™ä¸ªæ–¹æ³•å°†ç‹¬å å€Ÿç”¨è¯¥å¯¹è±¡ï¼Œç›´åˆ°å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç»“æŸâ€ã€‚å®é™…ä¸Šï¼Œè¿™æ„å‘³ç€ Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨åªä¼šå…è®¸åœ¨è¯¥å¯¹è±¡ä¸Šè°ƒç”¨è‡³å¤šä¸€æ¬¡ `some_method`, æ­¤åè¯¥å¯¹è±¡å°†ä¸€ç›´è¢«ç‹¬å å€Ÿç”¨å¹¶ä¼šå› æ­¤å˜å¾—ä¸å†å¯ç”¨ã€‚è¿™ç§ç”¨ä¾‹æå…¶ç½•è§ï¼Œä½†æ˜¯å› ä¸ºè¿™ç§ä»£ç èƒ½å¤Ÿé€šè¿‡ç¼–è¯‘ï¼Œæ‰€ä»¥é‚£äº›å¯¹ç”Ÿå‘½å‘¨æœŸè¿˜æ„Ÿåˆ°å›°æƒ‘çš„åˆå­¦è€…ä»¬å¾ˆå®¹æ˜“å†™å‡ºè¿™ç§ bug. ä¿®å¤è¿™ç§ bug çš„æ–¹å¼æ˜¯å»é™¤æ‰ä¸å¿…è¦çš„æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œè®© Rust ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™æ¥å¤„ç†å®ƒï¼š

```rust
#[derive(Debug)]
struct NumRef<'a>(&'a i32);

impl<'a> NumRef<'a> {
    // ä¸å†ç»™ mut self æ·»åŠ  'a æ³¨è§£
    fn some_method(&mut self) {}

    // ä¸Šä¸€è¡Œå»æ‰è¯­æ³•ç³–åï¼š
    fn some_method_desugared<'b>(&'b mut self){}
}

fn main() {
    let mut num_ref = NumRef(&5);
    num_ref.some_method();
    num_ref.some_method(); // ç¼–è¯‘é€šè¿‡
    println!("{:?}", num_ref); // ç¼–è¯‘é€šè¿‡
}
```

**å…³é”®ç‚¹å›é¡¾**
- Rust å¯¹å‡½æ•°çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¹¶ä¸ä¿è¯åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½æ­£ç¡®
- åœ¨ç¨‹åºçš„è¯­ä¹‰æ–¹é¢ï¼ŒRust å¹¶ä¸æ¯”ä½ æ‡‚
- å¯ä»¥è¯•è¯•ç»™ä½ çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£èµ·ä¸€ä¸ªæœ‰æ„ä¹‰çš„åå­—
- è¯•ç€è®°ä½ä½ åœ¨å“ªé‡Œæ·»åŠ äº†æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œä»¥åŠä¸ºä»€ä¹ˆè¦åŠ 



### 6) å·²è£…ç®±çš„ trait å¯¹è±¡ä¸å«ç”Ÿå‘½å‘¨æœŸæ³¨è§£

ä¹‹å‰æˆ‘ä»¬è®¨è®ºäº† Rust _å¯¹å‡½æ•°_ çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ã€‚Rust å¯¹ trait å¯¹è±¡ä¹Ÿå­˜åœ¨ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼Œå®ƒä»¬æ˜¯ï¼š
- å¦‚æœ trait å¯¹è±¡è¢«ç”¨ä½œæ³›å‹ç±»å‹çš„ä¸€ä¸ªç±»å‹å‚æ•°ï¼Œé‚£ä¹ˆ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸä¼šä¾æ®è¯¥ç±»å‹å‚æ•°çš„å®šä¹‰è¿›è¡Œæ¨å¯¼
    - è‹¥è¯¥ç±»å‹å‚æ•°æœ‰å”¯ä¸€çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œåˆ™å°†è¿™ä¸ªçº¦æŸèµ‹ç»™ trait å¯¹è±¡
    - è‹¥è¯¥ç±»å‹å‚æ•°ä¸æ­¢ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œåˆ™ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸéœ€è¦æ˜¾å¼æ ‡æ³¨
- å¦‚æœä¸Šé¢ä¸æˆç«‹ï¼Œä¹Ÿå°±æ˜¯è¯´è¯¥ç±»å‹å‚æ•°æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œé‚£ä¹ˆ
    - è‹¥ trait å®šä¹‰æ—¶æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œåˆ™å°†è¿™ä¸ªçº¦æŸèµ‹ç»™ trait å¯¹è±¡
    - è‹¥ trait å®šä¹‰æ—¶ç”Ÿå‘½å‘¨æœŸçº¦æŸä¸­å­˜åœ¨ä¸€ä¸ª `'static`, åˆ™å°† `'static` èµ‹ç»™ trait å¯¹è±¡
    - è‹¥ trait å®šä¹‰æ—¶æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œåˆ™å½“ trait å¯¹è±¡æ˜¯è¡¨è¾¾å¼çš„ä¸€éƒ¨åˆ†æ—¶ï¼Œç”Ÿå‘½å‘¨æœŸä»è¡¨è¾¾å¼ä¸­æ¨å¯¼è€Œå‡ºï¼Œå¦åˆ™èµ‹äºˆ `'static``

ä»¥ä¸Šè¿™äº›å¬èµ·æ¥ç‰¹åˆ«å¤æ‚ï¼Œä½†æ˜¯å¯ä»¥ç®€å•åœ°æ€»ç»“ä¸ºä¸€å¥è¯â€œä¸€ä¸ª trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸä»ä¸Šä¸‹æ–‡æ¨å¯¼è€Œå‡ºã€‚â€çœ‹ä¸‹é¢è¿™äº›ä¾‹å­åï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°ç”Ÿå‘½å‘¨æœŸçº¦æŸçš„æ¨å¯¼å…¶å®å¾ˆç¬¦åˆç›´è§‰ï¼Œå› æ­¤æˆ‘ä»¬æ²¡å¿…è¦å»è®°å¿†ä¸Šé¢çš„è§„åˆ™ï¼š

```rust
use std::cell::Ref;

trait Trait {}

// å±•å¼€å‰
type T1 = Box<dyn Trait>;
// å±•å¼€åï¼ŒBox<T> æ²¡æœ‰å¯¹ T çš„ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼Œæ‰€ä»¥æ¨å¯¼ä¸º 'static
type T2 = Box<dyn Trait + 'static>;

// å±•å¼€å‰
impl dyn Trait {}
// å±•å¼€å
impl dyn Trait + 'static {}

// å±•å¼€å‰
type T3<'a> = &'a dyn Trait;
// å±•å¼€åï¼Œ&'a T è¦æ±‚ T: 'a, æ‰€ä»¥æ¨å¯¼ä¸º 'a
type T4<'a> = &'a (dyn Trait + 'a);

// å±•å¼€å‰
type T5<'a> = Ref<'a, dyn Trait>;
// å±•å¼€åï¼ŒRef<'a, T> è¦æ±‚ T: 'a, æ‰€ä»¥æ¨å¯¼ä¸º 'a
type T6<'a> = Ref<'a, dyn Trait + 'a>;

trait GenericTrait<'a>: 'a {}

// å±•å¼€å‰
type T7<'a> = Box<dyn GenericTrait<'a>>;
// å±•å¼€å
type T8<'a> = Box<dyn GenericTrait<'a> + 'a>;

// å±•å¼€å‰
impl<'a> dyn GenericTrait<'a> {}
// å±•å¼€å
impl<'a> dyn GenericTrait<'a> + 'a {}
```

ä¸€ä¸ªå®ç°äº† trait çš„å…·ä½“ç±»å‹å¯ä»¥è¢«å¼•ç”¨ï¼Œå› æ­¤å®ƒä»¬ä¹Ÿä¼šæœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸï¼ŒåŒæ ·å…¶å¯¹åº”çš„ trait å¯¹è±¡ä¹Ÿæœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸã€‚ä½ ä¹Ÿå¯ä»¥ç›´æ¥å¯¹å¼•ç”¨å®ç° trait, å¼•ç”¨æ˜¾ç„¶æ˜¯æœ‰ç”Ÿå‘½å‘¨æœŸçº¦æŸçš„ï¼š

```rust
trait Trait {}

struct Struct {}
struct Ref<'a, T>(&'a T);

impl Trait for Struct {}
impl Trait for &Struct {} // ç›´æ¥ä¸ºå¼•ç”¨ç±»å‹å®ç° Trait
impl<'a, T> Trait for Ref<'a, T> {} // ä¸ºåŒ…å«å¼•ç”¨çš„ç±»å‹å®ç° Trait
```

æ€»ä¹‹ï¼Œè¿™ä¸ªçŸ¥è¯†ç‚¹å€¼å¾—åå¤ç†è§£ï¼Œæ–°æ‰‹åœ¨é‡æ„ä¸€ä¸ªä½¿ç”¨ trait å¯¹è±¡çš„å‡½æ•°åˆ°ä¸€ä¸ªæ³›å‹çš„å‡½æ•°æˆ–è€…åè¿‡æ¥æ—¶ï¼Œå¸¸å¸¸ä¼šå› ä¸ºè¿™ä¸ªçŸ¥è¯†ç‚¹è€Œæ„Ÿåˆ°å›°æƒ‘ã€‚æ¥çœ‹çœ‹è¿™ä¸ªç¤ºä¾‹ç¨‹åºï¼š

```rust
use std::fmt::Display;

fn dynamic_thread_print(t: Box<dyn Display + Send>) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}

fn static_thread_print<T: Display + Send>(t: T) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}
```

è¿™é‡Œç¼–è¯‘å™¨æŠ¥é”™ï¼š

```rust
error[E0310]: the parameter type `T` may not live long enough
  --> src/lib.rs:10:5
   |
9  | fn static_thread_print<T: Display + Send>(t: T) {
   |                        -- help: consider adding an explicit lifetime bound...: `T: 'static +`
10 |     std::thread::spawn(move || {
   |     ^^^^^^^^^^^^^^^^^^
   |
note: ...so that the type `[closure@src/lib.rs:10:24: 12:6 t:T]` will meet its required lifetime bounds
  --> src/lib.rs:10:5
   |
10 |     std::thread::spawn(move || {
   |     ^^^^^^^^^^^^^^^^^^
```

å¾ˆå¥½ï¼Œç¼–è¯‘å™¨å‘Šè¯‰äº†æˆ‘ä»¬æ€æ ·ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œè®©æˆ‘ä»¬ä¿®å¤ä¸€ä¸‹ã€‚

```rust
use std::fmt::Display;

fn dynamic_thread_print(t: Box<dyn Display + Send>) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}

fn static_thread_print<T: Display + Send + 'static>(t: T) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}
```

ç°åœ¨å®ƒç¼–è¯‘é€šè¿‡äº†ï¼Œä½†æ˜¯è¿™ä¸¤ä¸ªå‡½æ•°å¯¹æ¯”èµ·æ¥çœ‹èµ·æ¥æŒºå¥‡æ€ªçš„ï¼Œä¸ºä»€ä¹ˆç¬¬äºŒä¸ªå‡½æ•°è¦æ±‚ `T` æ»¡è¶³ `'static` çº¦æŸè€Œç¬¬ä¸€ä¸ªå‡½æ•°ä¸ç”¨å‘¢ï¼Ÿè¿™æ˜¯ä¸ªåˆé’»çš„é—®é¢˜ã€‚äº‹å®ä¸Šï¼Œé€šè¿‡ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ï¼ŒRust è‡ªåŠ¨åœ¨ç¬¬ä¸€ä¸ªå‡½æ•°é‡Œæ¨å¯¼å¹¶æ·»åŠ äº†ä¸€ä¸ª `'static` çº¦æŸï¼Œæ‰€ä»¥å…¶å®ä¸¤ä¸ªå‡½æ•°éƒ½å«æœ‰ `'static` çº¦æŸã€‚Rust ç¼–è¯‘å™¨å®é™…çœ‹åˆ°çš„æ˜¯è¿™ä¸ªæ ·å­çš„ï¼š

```rust
use std::fmt::Display;

fn dynamic_thread_print(t: Box<dyn Display + Send + 'static>) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}

fn static_thread_print<T: Display + Send + 'static>(t: T) {
    std::thread::spawn(move || {
        println!("{}", t);
    }).join();
}
```

å…³é”®ç‚¹å›é¡¾
- æ‰€æœ‰ trait å¯¹è±¡éƒ½å«æœ‰è‡ªåŠ¨æ¨å¯¼çš„ç”Ÿå‘½å‘¨æœŸ



### 7) ç¼–è¯‘å™¨çš„æŠ¥é”™ä¿¡æ¯ä¼šå‘Šè¯‰æˆ‘æ€æ ·ä¿®å¤æˆ‘çš„ç¨‹åº

**é”™è¯¯çš„æ¨è®º**
- Rust å¯¹ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™æ€»æ˜¯æ­£ç¡®çš„
- Rust æ¯”æˆ‘æ›´æ‡‚æˆ‘ç¨‹åºçš„è¯­ä¹‰

è¿™ä¸ªè¯¯è§£æ˜¯å‰ä¸¤ä¸ªè¯¯è§£çš„ç»“åˆï¼Œæ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```rust
use std::fmt::Display;

fn box_displayable<T: Display>(t: T) -> Box<dyn Display> {
    Box::new(t)
}
```

æŠ¥é”™å¦‚ä¸‹ï¼š

```rust
error[E0310]: the parameter type `T` may not live long enough
 --> src/lib.rs:4:5
  |
3 | fn box_displayable<T: Display>(t: T) -> Box<dyn Display> {
  |                    -- help: consider adding an explicit lifetime bound...: `T: 'static +`
4 |     Box::new(t)
  |     ^^^^^^^^^^^
  |
note: ...so that the type `T` will meet its required lifetime bounds
 --> src/lib.rs:4:5
  |
4 |     Box::new(t)
  |     ^^^^^^^^^^^
```

å¥½ï¼Œè®©æˆ‘ä»¬æŒ‰ç…§ç¼–è¯‘å™¨çš„æç¤ºè¿›è¡Œä¿®å¤ã€‚è¿™é‡Œæˆ‘ä»¬å…ˆå¿½ç•¥ä¸€ä¸ªäº‹å®ï¼šè¿”å›å€¼ä¸­è£…ç®±çš„ trait å¯¹è±¡æœ‰ä¸€ä¸ªè‡ªåŠ¨æ¨å¯¼çš„ `'static` çº¦æŸï¼Œè€Œç¼–è¯‘å™¨æ˜¯åŸºäºè¿™ä¸ªæ²¡æœ‰æ˜¾å¼è¯´æ˜çš„äº‹å®ç»™å‡ºçš„ä¿®å¤å»ºè®®ã€‚

```rust
use std::fmt::Display;

fn box_displayable<T: Display + 'static>(t: T) -> Box<dyn Display> {
    Box::new(t)
}
```

ç°åœ¨å¯ä»¥ç¼–è¯‘é€šè¿‡äº†ï¼Œä½†è¿™çœŸçš„æ˜¯æˆ‘ä»¬æƒ³è¦çš„å—ï¼Ÿå¯èƒ½æ˜¯ï¼Œä¹Ÿå¯èƒ½ä¸æ˜¯ï¼Œç¼–è¯‘å™¨å¹¶æ²¡æœ‰æåˆ°å…¶ä»–ä¿®å¤æ–¹æ¡ˆï¼Œä½†ä¸‹é¢è¿™ä¸ªä¹Ÿæ˜¯ä¸€ä¸ªåˆé€‚çš„ä¿®å¤æ–¹æ¡ˆã€‚

```rust
use std::fmt::Display;

fn box_displayable<'a, T: Display + 'a>(t: T) -> Box<dyn Display + 'a> {
    Box::new(t)
}
```

è¿™ä¸ªå‡½æ•°æ‰€èƒ½æ¥å—çš„å®é™…å‚æ•°æ¯”å‰ä¸€ä¸ªå‡½æ•°å¤šäº†ä¸å°‘ï¼è¿™ä¸ªå‡½æ•°æ˜¯ä¸æ˜¯æ›´å¥½ï¼Ÿç¡®å®ï¼Œä½†ä¸ä¸€å®šå¿…è¦ï¼Œè¿™å–å†³äºæˆ‘ä»¬å¯¹ç¨‹åºçš„è¦æ±‚ä¸çº¦æŸã€‚ä¸Šé¢è¿™ä¸ªä¾‹å­æœ‰ç‚¹æŠ½è±¡ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªæ›´ç®€å•æ˜äº†çš„ä¾‹å­ï¼š

```rust
fn return_first(a: &str, b: &str) -> &str {
    a
}
```

æŠ¥é”™ï¼š

```rust
error[E0106]: missing lifetime specifier
 --> src/lib.rs:1:38
  |
1 | fn return_first(a: &str, b: &str) -> &str {
  |                    ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`
help: consider introducing a named lifetime parameter
  |
1 | fn return_first<'a>(a: &'a str, b: &'a str) -> &'a str {
  |                ^^^^    ^^^^^^^     ^^^^^^^     ^^^
```

è¿™ä¸ªé”™è¯¯ä¿¡æ¯æ¨èæˆ‘ä»¬ç»™æ‰€æœ‰è¾“å…¥è¾“å‡ºéƒ½æ ‡æ³¨ä¸ŠåŒæ ·çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚å¦‚æœæˆ‘ä»¬è¿™ä¹ˆåšäº†ï¼Œé‚£ä¹ˆç¨‹åºå°†é€šè¿‡ç¼–è¯‘ï¼Œä½†æ˜¯è¿™æ ·å†™å‡ºçš„å‡½æ•°è¿‡åº¦é™åˆ¶äº†è¿”å›ç±»å‹ã€‚æˆ‘ä»¬çœŸæ­£æƒ³è¦çš„æ˜¯è¿™ä¸ªï¼š

```rust
fn return_first<'a>(a: &'a str, b: &str) -> &'a str {
    a
}
```

**å…³é”®ç‚¹å›é¡¾**
- Rust å¯¹ trait å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¹¶ä¸ä¿è¯åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½æ­£ç¡®
- åœ¨ç¨‹åºçš„è¯­ä¹‰æ–¹é¢ï¼ŒRust å¹¶ä¸æ¯”ä½ æ‡‚
- Rust ç¼–è¯‘é”™è¯¯çš„æç¤ºä¿¡æ¯æ‰€æå‡ºçš„ä¿®å¤æ–¹æ¡ˆå¹¶ä¸ä¸€å®šèƒ½æ»¡è¶³ä½ å¯¹ç¨‹åºçš„éœ€æ±‚



### 8) ç”Ÿå‘½å‘¨æœŸå¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€å˜é•¿æˆ–å˜çŸ­

**é”™è¯¯çš„æ¨è®º**
- å®¹å™¨ç±»å¯ä»¥åœ¨è¿è¡Œæ—¶äº¤æ¢å…¶å†…éƒ¨çš„å¼•ç”¨ï¼Œä»è€Œæ”¹å˜è‡ªèº«çš„ç”Ÿå‘½å‘¨æœŸ
- Rust å€Ÿç”¨æ£€æŸ¥å™¨èƒ½è¿›è¡Œé«˜çº§çš„æ§åˆ¶æµåˆ†æ

è¿™ä¸ªç¼–è¯‘ä¸é€šè¿‡ï¼š

```rust
struct Has<'lifetime> {
    lifetime: &'lifetime str,
}

fn main() {
    let long = String::from("long");
    let mut has = Has { lifetime: &long };
    assert_eq!(has.lifetime, "long");

    {
        let short = String::from("short");
        // â€œè½¬æ¢åˆ°â€ çŸ­çš„ç”Ÿå‘½å‘¨æœŸ
        has.lifetime = &short;
        assert_eq!(has.lifetime, "short");

        // â€œè½¬æ¢å›â€ é•¿çš„ç”Ÿå‘½å‘¨æœŸï¼ˆå®é™…æ˜¯å¹¶ä¸æ˜¯ï¼‰
        has.lifetime = &long;
        assert_eq!(has.lifetime, "long");
        // `short` å˜é‡åœ¨è¿™é‡Œ drop
    }

    // ç¼–è¯‘å¤±è´¥ï¼Œ `short` åœ¨ drop åä»æ—§å¤„äº â€œå€Ÿç”¨â€ çŠ¶æ€
    assert_eq!(has.lifetime, "long");
}
```

æŠ¥é”™ï¼š

```rust
error[E0597]: `short` does not live long enough
  --> src/main.rs:11:24
   |
11 |         has.lifetime = &short;
   |                        ^^^^^^ borrowed value does not live long enough
...
15 |     }
   |     - `short` dropped here while still borrowed
16 |     assert_eq!(has.lifetime, "long");
   |     --------------------------------- borrow later used here
```

ä¸‹é¢è¿™ä¸ªè¿˜æ˜¯æŠ¥é”™ï¼ŒæŠ¥é”™ä¿¡æ¯ä¹Ÿå’Œä¸Šé¢ä¸€æ ·ï¼š

```rust
struct Has<'lifetime> {
    lifetime: &'lifetime str,
}

fn main() {
    let long = String::from("long");
    let mut has = Has { lifetime: &long };
    assert_eq!(has.lifetime, "long");

    // è¿™ä¸ªä»£ç å—é€»è¾‘ä¸Šæ°¸è¿œä¸ä¼šè¢«æ‰§è¡Œ
    if false {
        let short = String::from("short");
        // â€œè½¬æ¢åˆ°â€ çŸ­çš„ç”Ÿå‘½å‘¨æœŸ
        has.lifetime = &short;
        assert_eq!(has.lifetime, "short");

        // â€œè½¬æ¢å›â€ é•¿çš„ç”Ÿå‘½å‘¨æœŸï¼ˆå®é™…æ˜¯å¹¶ä¸æ˜¯ï¼‰
        has.lifetime = &long;
        assert_eq!(has.lifetime, "long");
        // `short` å˜é‡åœ¨è¿™é‡Œ drop
    }

    // è¿˜æ˜¯ç¼–è¯‘å¤±è´¥ï¼Œ `short` åœ¨ drop åä»æ—§å¤„äº â€œå€Ÿç”¨â€ çŠ¶æ€
    assert_eq!(has.lifetime, "long");
}
```

ç”Ÿå‘½å‘¨æœŸå¿…é¡»åœ¨ç¼–è¯‘æ—¶è¢«é™æ€ç¡®å®šï¼Œè€Œä¸” Rust å€Ÿç”¨æ£€æŸ¥å™¨åªä¼šåšåŸºæœ¬çš„æ§åˆ¶æµåˆ†æï¼Œæ‰€ä»¥å®ƒå‡è®¾æ¯ä¸ª `if-else` å—å’Œ `match` å—çš„æ¯ä¸ªåˆ†æ”¯éƒ½èƒ½è¢«æ‰§è¡Œï¼Œç„¶åé€‰å‡ºä¸€ä¸ªæœ€çŸ­çš„ç”Ÿå‘½å‘¨æœŸèµ‹ç»™å—ä¸­çš„å˜é‡ã€‚ä¸€æ—¦ä¸€ä¸ªå˜é‡è¢«ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸçº¦æŸäº†ï¼Œé‚£ä¹ˆå®ƒå°† _æ°¸è¿œ_ è¢«è¿™ä¸ªç”Ÿå‘½å‘¨æœŸæ‰€çº¦æŸã€‚ä¸€ä¸ªå˜é‡çš„ç”Ÿå‘½å‘¨æœŸåªèƒ½ç¼©çŸ­ï¼Œè€Œä¸”æ‰€æœ‰çš„ç¼©çŸ­æ—¶æœºéƒ½åœ¨ç¼–è¯‘æ—¶ç¡®å®šã€‚

**å…³é”®ç‚¹å›é¡¾**
- ç”Ÿå‘½å‘¨æœŸåœ¨ç¼–è¯‘æ—¶è¢«é™æ€ç¡®å®š
- ç”Ÿå‘½å‘¨æœŸåœ¨è¿è¡Œæ—¶ä¸èƒ½è¢«æ”¹å˜
- Rust å€Ÿç”¨æ£€æŸ¥å™¨å‡è®¾æ‰€æœ‰ä»£ç è·¯å¾„éƒ½èƒ½è¢«æ‰§è¡Œï¼Œæ‰€ä»¥æ€»æ˜¯é€‰æ‹©å°½å¯èƒ½çŸ­çš„ç”Ÿå‘½å‘¨æœŸèµ‹ç»™å˜é‡



### 9) å°†ç‹¬å å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨æ˜¯ safe çš„

**é”™è¯¯çš„æ¨è®º**
- é€šè¿‡é‡å€Ÿç”¨å¼•ç”¨å†…éƒ¨çš„æ•°æ®ï¼Œèƒ½æŠ¹æ‰å…¶åŸæœ‰çš„ç”Ÿå‘½å‘¨æœŸï¼Œç„¶åèµ‹ä¸€ä¸ªæ–°çš„ä¸Šå»

ä½ å¯ä»¥å°†ä¸€ä¸ªç‹¬å å¼•ç”¨ä½œä¸ºå‚æ•°ä¼ ç»™ä¸€ä¸ªæ¥æ”¶å…±äº«å¼•ç”¨çš„å‡½æ•°ï¼Œå› ä¸º Rust å°†éšå¼åœ°é‡å€Ÿç”¨ç‹¬å å¼•ç”¨å†…éƒ¨çš„æ•°æ®ï¼Œç”Ÿæˆä¸€ä¸ªå…±äº«å¼•ç”¨ï¼š

```rust
fn takes_shared_ref(n: &i32) {}

fn main() {
    let mut a = 10;
    takes_shared_ref(&mut a); // ç¼–è¯‘é€šè¿‡
    takes_shared_ref(&*(&mut a)); // ä¸Šé¢é‚£è¡Œå»æ‰è¯­æ³•ç³–
}
```

è¿™åœ¨ç›´è§‰ä¸Šæ˜¯åˆç†çš„ï¼Œå› ä¸ºå°†ä¸€ä¸ªç‹¬å å¼•ç”¨è½¬æ¢ä¸ºå…±äº«å¼•ç”¨æ˜¾ç„¶æ˜¯æ— å®³çš„ï¼Œå¯¹å—ï¼Ÿä»¤äººè®¶å¼‚çš„æ˜¯ï¼Œè¿™å¹¶ä¸å¯¹ï¼Œä¸‹é¢çš„è¿™æ®µç¨‹åºä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼š

```rust
fn main() {
    let mut a = 10;
    let b: &i32 = &*(&mut a); // é‡å€Ÿç”¨ä¸ºä¸å¯å˜å¼•ç”¨
    let c: &i32 = &a;
    dbg!(b, c); // ç¼–è¯‘å¤±è´¥
}
```

æŠ¥é”™å¦‚ä¸‹ï¼š

```rust
error[E0502]: cannot borrow `a` as immutable because it is also borrowed as mutable
 --> src/main.rs:4:19
  |
3 |     let b: &i32 = &*(&mut a);
  |                     -------- mutable borrow occurs here
4 |     let c: &i32 = &a;
  |                   ^^ immutable borrow occurs here
5 |     dbg!(b, c);
  |          - mutable borrow later used here
```

ä»£ç é‡Œç¡®å®æœ‰ä¸€ä¸ªç‹¬å å¼•ç”¨ï¼Œä½†æ˜¯å®ƒç«‹å³é‡å€Ÿç”¨å˜æˆäº†ä¸€ä¸ªå…±äº«å¼•ç”¨ï¼Œç„¶åè‡ªèº«å°±è¢« drop æ‰äº†ã€‚ä½†æ˜¯ä¸ºä»€ä¹ˆ Rust å¥½åƒæŠŠè¿™ä¸ªé‡å€Ÿç”¨å‡ºæ¥çš„å…±äº«å¼•ç”¨çœ‹ä½œæ˜¯æœ‰ä¸€ä¸ªç‹¬å çš„ç”Ÿå‘½å‘¨æœŸå‘¢ï¼Ÿä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­ï¼Œå…è®¸ç‹¬å å¼•ç”¨ç›´æ¥é™çº§ä¸ºå…±äº«å¼•ç”¨æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œä½†æ˜¯è¿™ä¸ªå…è®¸ç¡®å®ä¼šå¯¼è‡´æ½œåœ¨çš„å†…å­˜å®‰å…¨é—®é¢˜ã€‚

```rust
use std::sync::Mutex;

struct Struct {
    mutex: Mutex<String>
}

impl Struct {
    // å°† self çš„ç‹¬å å¼•ç”¨é™çº§ä¸º str çš„å…±äº«å¼•ç”¨
    fn get_string(&mut self) -> &str {
        self.mutex.get_mut().unwrap()
    }
    fn mutate_string(&self) {
        // å¦‚æœ Rust å…è®¸ç‹¬å å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨ï¼Œé‚£ä¹ˆä¸‹é¢è¿™ä¸€è¡Œä»£ç æ‰§è¡Œåï¼Œ
        // æ‰€æœ‰é€šè¿‡ get_string æ–¹æ³•è¿”å›çš„ &str éƒ½å°†å˜ä¸ºéæ³•å¼•ç”¨
        *self.mutex.lock().unwrap() = "surprise!".to_owned();
    }
}

fn main() {
    let mut s = Struct {
        mutex: Mutex::new("string".to_owned())
    };
    let str_ref = s.get_string(); // ç‹¬å å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨
    s.mutate_string(); // str_ref å¤±æ•ˆï¼Œå˜æˆéæ³•å¼•ç”¨ï¼Œç°åœ¨æ˜¯ä¸€ä¸ªæ‚¬å‚æŒ‡é’ˆ
    dbg!(str_ref); // å½“ç„¶ï¼Œå®é™…ä¸Šä¼šç¼–è¯‘é”™è¯¯
}
```

è¿™é‡Œçš„å…³é”®ç‚¹åœ¨äºï¼Œä½ åœ¨é‡å€Ÿç”¨ä¸€ä¸ªç‹¬å å¼•ç”¨ä¸ºå…±äº«å¼•ç”¨æ—¶ï¼Œå°±å·²ç»è½å…¥äº†ä¸€ä¸ªé™·é˜±ï¼šä¸ºäº†ä¿è¯é‡å€Ÿç”¨å¾—åˆ°çš„å…±äº«å¼•ç”¨åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…æœ‰æ•ˆï¼Œè¢«é‡å€Ÿç”¨çš„ç‹¬å å¼•ç”¨ä¹Ÿå¿…é¡»ä¿è¯åœ¨è¿™æ®µæ—¶æœŸæœ‰æ•ˆï¼Œè¿™å»¶é•¿äº†ç‹¬å å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼å“ªæ€•ç‹¬å å¼•ç”¨è‡ªèº«å·²ç»è¢« drop æ‰äº†ï¼Œä½†ç‹¬å å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå´ä¸€ç›´å»¶ç»­åˆ°å…±äº«å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸç»“æŸã€‚

ä½¿ç”¨é‡å€Ÿç”¨å¾—åˆ°çš„å…±äº«å¼•ç”¨æ˜¯å¾ˆéš¾å—çš„ï¼Œå› ä¸ºå®ƒæ˜æ˜æ˜¯ä¸€ä¸ªå…±äº«å¼•ç”¨ä½†æ˜¯å´ä¸èƒ½å’Œå…¶ä»–å…±äº«å¼•ç”¨å…±å­˜ã€‚é‡å€Ÿç”¨å¾—åˆ°çš„å…±äº«å¼•ç”¨æœ‰ç€ç‹¬å å¼•ç”¨å’Œå…±äº«å¼•ç”¨çš„ç¼ºç‚¹ï¼Œå´æ²¡æœ‰äºŒè€…çš„ä¼˜ç‚¹ã€‚æˆ‘è®¤ä¸ºé‡å€Ÿç”¨ä¸€ä¸ªç‹¬å å¼•ç”¨ä¸ºå…±äº«å¼•ç”¨çš„è¡Œä¸ºåº”å½“è¢«è§†ä¸º Rust çš„ä¸€ç§åæ¨¡å¼ã€‚çŸ¥é“è¿™ç§åæ¨¡å¼æ˜¯å¾ˆé‡è¦çš„ï¼Œå½“ä½ çœ‹åˆ°è¿™æ ·çš„ä»£ç æ—¶ï¼Œä½ å°±èƒ½è½»æ˜“åœ°å‘ç°é”™è¯¯äº†ï¼š

```rust
// å°†ç‹¬å å¼•ç”¨é™çº§ä¸ºå…±äº«å¼•ç”¨
fn some_function<T>(some_arg: &mut T) -> &T;

struct Struct;

impl Struct {
    // å°†ç‹¬å çš„ self å¼•ç”¨é™çº§ä¸ºå…±äº«çš„ self å¼•ç”¨
    fn some_method(&mut self) -> &self;

    // å°†ç‹¬å çš„ self å¼•ç”¨é™çº§ä¸ºå…±äº«çš„ T å¼•ç”¨
    fn other_method(&mut self) -> &T;
}
```

å°½ç®¡ä½ å¯ä»¥åœ¨å‡½æ•°å’Œæ–¹æ³•çš„å£°æ˜é‡Œé¿å…é‡å€Ÿç”¨ï¼Œä½†æ˜¯ç”±äº Rust ä¼šè‡ªåŠ¨åšéšå¼é‡å€Ÿç”¨ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“æ— æ„è¯†åœ°é‡åˆ°è¿™ç§æƒ…å†µã€‚

```rust
use std::collections::HashMap;

type PlayerID = i32;

#[derive(Debug, Default)]
struct Player {
    score: i32,
}

fn start_game(player_a: PlayerID, player_b: PlayerID, server: &mut HashMap<PlayerID, Player>) {
    // ä» server ä¸­å¾—åˆ° player, å¦‚æœä¸å­˜åœ¨å°±åˆ›å»ºä¸€ä¸ªé»˜è®¤çš„ player å¹¶å¾—åˆ°è¿™ä¸ªæ–°åˆ›å»ºçš„ã€‚
    let player_a: &Player = server.entry(player_a).or_default();
    let player_b: &Player = server.entry(player_b).or_default();

    // å¯¹å¾—åˆ°çš„ player åšä¸€äº›æ“ä½œ
    dbg!(player_a, player_b); // ç¼–è¯‘é”™è¯¯
}
```

ä¸Šé¢è¿™æ®µä»£ç ä¼šç¼–è¯‘å¤±è´¥ã€‚è¿™é‡Œ `or_default()` ä¼šè¿”å›ä¸€ä¸ª `&mut Player`ï¼Œä½†æ˜¯ç”±äºæˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ªæ˜¾å¼çš„ç±»å‹æ ‡æ³¨ï¼Œå®ƒä¼šè¢«éšå¼é‡å€Ÿç”¨æˆ `&Player`ã€‚è€Œä¸ºäº†è¾¾æˆæˆ‘ä»¬çœŸæ­£çš„ç›®çš„ï¼Œæˆ‘ä»¬ä¸å¾—ä¸è¿™æ ·åšï¼š

```rust
use std::collections::HashMap;

type PlayerID = i32;

#[derive(Debug, Default)]
struct Player {
    score: i32,
}

fn start_game(player_a: PlayerID, player_b: PlayerID, server: &mut HashMap<PlayerID, Player>) {
    // å› ä¸ºç¼–è¯‘å™¨ä¸å…è®¸è¿™ä¸¤ä¸ªè¿”å›å€¼å…±å­˜ï¼Œæ‰€æœ‰è¿™é‡Œç›´æ¥ä¸¢å¼ƒè¿™ä¸¤ä¸ª &mut Player
    server.entry(player_a).or_default();
    server.entry(player_b).or_default();

    // å†æ¬¡è·å– player, è¿™æ¬¡æˆ‘ä»¬ç›´æ¥æ‹¿åˆ°å…±äº«å¼•ç”¨ï¼Œé¿å…éšå¼çš„é‡å€Ÿç”¨
    let player_a = server.get(&player_a);
    let player_b = server.get(&player_b);

    // å¯¹å¾—åˆ°çš„ player åšä¸€äº›æ“ä½œ
    dbg!(player_a, player_b); // ç°åœ¨èƒ½ç¼–è¯‘é€šè¿‡äº†
}
```

éš¾ç”¨ï¼Œè€Œä¸”å¾ˆè ¢ï¼Œä½†è¿™æ˜¯æˆ‘ä»¬ä¸ºäº†å†…å­˜å®‰å…¨è¿™ä¸€ä¿¡æ¡æ‰€åšå‡ºçš„ç‰ºç‰²ã€‚

**å…³é”®ç‚¹å›é¡¾**
- å°½é‡é¿å…é‡å€Ÿç”¨ä¸€ä¸ªç‹¬å å¼•ç”¨ä¸ºå…±äº«å¼•ç”¨ï¼Œä¸ç„¶ä½ ä¼šé‡åˆ°å¾ˆå¤šéº»çƒ¦
- é‡å€Ÿç”¨ä¸€ä¸ªç‹¬å å¼•ç”¨å¹¶ä¸ä¼šç»“æŸå…¶ç”Ÿå‘½å‘¨æœŸï¼Œå“ªæ€•å®ƒè‡ªèº«å·²ç»è¢« drop æ‰äº†



### 10) å¯¹é—­åŒ…çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å’Œå‡½æ•°ä¸€æ ·

è¿™æ›´åƒæ˜¯ Rust çš„é™·é˜±è€Œéè¯¯è§£

å°½ç®¡é—­åŒ…å¯ä»¥è¢«å½“ä½œæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä½†æ˜¯å¹¶ä¸éµå¾ªå’Œå‡½æ•°åŒæ ·çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ã€‚

```rust
fn function(x: &i32) -> &i32 {
    x
}

fn main() {
    let closure = |x: &i32| x;
}
```

æŠ¥é”™ï¼š

```rust
error: lifetime may not live long enough
 --> src/main.rs:6:29
  |
6 |     let closure = |x: &i32| x;
  |                       -   - ^ returning this value requires that `'1` must outlive `'2`
  |                       |   |
  |                       |   return type of closure is &'2 i32
  |                       let's call the lifetime of this reference `'1`
```

å»æ‰è¯­æ³•ç³–åï¼Œæˆ‘ä»¬å¾—åˆ°çš„æ˜¯ï¼š

```rust
// è¾“å…¥çš„ç”Ÿå‘½å‘¨æœŸåº”ç”¨åˆ°äº†è¾“å‡ºä¸Š
fn function<'a>(x: &'a i32) -> &'a i32 {
    x
}

fn main() {
    // è¾“å…¥å’Œè¾“å‡ºæœ‰å®ƒä»¬è‡ªå·±å„è‡ªçš„ç”Ÿå‘½å‘¨æœŸ
    let closure = for<'a, 'b> |x: &'a i32| -> &'b i32 { x };
    // æ³¨æ„ï¼šä¸Šä¸€è¡Œå¹¶ä¸æ˜¯åˆæ³•çš„è¯­å¥ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦å®ƒæ¥æè¿°æˆ‘ä»¬ç›®çš„
}
```

å‡ºç°è¿™ç§å·®å¼‚å¹¶æ²¡æœ‰ä»€ä¹ˆå¥½å¤„ã€‚åªæ˜¯åœ¨é—­åŒ…æœ€åˆçš„å®ç°ä¸­ï¼Œä½¿ç”¨çš„ç±»å‹æ¨æ–­è¯­ä¹‰ä¸å‡½æ•°ä¸åŒï¼Œè€Œç°åœ¨å°†äºŒè€…åšä¸€ä¸ªç»Ÿä¸€å°†æ˜¯ä¸€ä¸ª breaking change, å› æ­¤ç°åœ¨å·²ç»æ²¡æ³•æ”¹äº†ã€‚é‚£ä¹ˆæˆ‘ä»¬æ€ä¹ˆæ˜¾å¼åœ°æ ‡æ³¨ä¸€ä¸ªé—­åŒ…çš„ç±»å‹å‘¢ï¼Ÿæˆ‘ä»¬æœ‰ä»¥ä¸‹å‡ ç§æ–¹æ¡ˆï¼š

```rust
fn main() {
    // è½¬æ¢æˆ trait å¯¹è±¡ï¼Œä½†è¿™æ ·æ˜¯ä¸å®šé•¿çš„ï¼Œæ‰€ä»¥ä¼šç¼–è¯‘é”™è¯¯
    let identity: dyn Fn(&i32) -> &i32 = |x: &i32| x;

    // å¯ä»¥åˆ†é…åˆ°å †ä¸Šä½œä¸ºæ›¿ä»£æ–¹æ¡ˆï¼Œä½†æ˜¯åœ¨è¿™é‡Œå †åˆ†é…æ„Ÿè§‰æœ‰ç‚¹è ¢
    let identity: Box<dyn Fn(&i32) -> &i32> = Box::new(|x: &i32| x);

    // å¯ä»¥ä¸ç”¨å †åˆ†é…è€Œç›´æ¥åˆ›å»ºä¸€ä¸ª 'static å¼•ç”¨
    let identity: &dyn Fn(&i32) -> &i32 = &|x: &i32| x;

    // ä¸Šä¸€è¡Œå»æ‰è¯­æ³•ç³– :)
    let identity: &'static (dyn for<'a> Fn(&'a i32) -> &'a i32 + 'static) = &|x: &i32| -> &i32 { x };

    // è¿™çœ‹èµ·æ¥å¾ˆå®Œç¾ï¼Œä½†å¯æƒœä¸ç¬¦åˆè¯­æ³•
    let identity: impl Fn(&i32) -> &i32 = |x: &i32| x;

    // è¿™ä¸ªä¹Ÿè¡Œï¼Œä½†ä¹Ÿä¸ç¬¦åˆè¯­æ³•
    let identity = for<'a> |x: &'a i32| -> &'a i32 { x };

    // ä½†æ˜¯ "impl trait" å¯ä»¥ä½œä¸ºå‡½æ•°çš„è¿”å›å€¼ç±»å‹
    fn return_identity() -> impl Fn(&i32) -> &i32 {
        |x| x
    }
    let identity = return_identity();

    // ä¸Šä¸€ä¸ªè§£å†³æ–¹æ¡ˆçš„æ³›åŒ–ç‰ˆæœ¬
    fn annotate<T, F>(f: F) -> F where F: Fn(&T) -> &T {
        f
    }
    let identity = annotate(|x: &i32| x);
}
```

æˆ‘æƒ³ä½ åº”è¯¥æ³¨æ„åˆ°äº†ï¼Œåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå¦‚æœå¯¹é—­åŒ…åº”ç”¨ trait çº¦æŸï¼Œé—­åŒ…ä¼šå’Œå‡½æ•°éµå¾ªåŒæ ·çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™ã€‚

è¿™é‡Œæ²¡æœ‰ä»€ä¹ˆç°å®çš„æ•™è®­æˆ–è§è§£ï¼Œåªæ˜¯è¯´æ˜ä¸€ä¸‹é—­åŒ…æ˜¯è¿™æ ·çš„ã€‚

**å…³é”®ç‚¹å›é¡¾**
- æ¯ä¸ªè¯­è¨€éƒ½æœ‰å…¶é™·é˜± ğŸ¤·


### 11) `'static` å¼•ç”¨æ€»èƒ½è¢«å¼ºåˆ¶è½¬æ¢ä¸º `'a` å¼•ç”¨

æˆ‘ä¹‹å‰æœ‰è¿‡è¿™æ ·çš„ä»£ç ï¼š

```rust
fn get_str<'a>() -> &'a str; // æ³›å‹ç‰ˆæœ¬
fn get_str() -> &'static str; // 'static ç‰ˆæœ¬
```

ä¸€äº›è¯»è€…è”ç³»æˆ‘ï¼Œé—®è¿™ä¸¤è€…ä¹‹é—´æ˜¯å¦æœ‰å®é™…çš„å·®å¼‚ã€‚æˆ‘ä¸€å¼€å§‹å¹¶ä¸ç¡®å®šï¼Œä½†ä¸€ç•ªç ”ç©¶è¿‡åé—æ†¾åœ°å‘ç°ï¼Œæ˜¯çš„ï¼Œè¿™äºŒè€…ç¡®å®æœ‰å·®å¼‚ã€‚

é€šå¸¸åœ¨ä½¿ç”¨å€¼æ—¶ï¼Œæˆ‘ä»¬èƒ½ç”¨ `'static` å¼•ç”¨ç›´æ¥ä»£æ›¿ä¸€ä¸ª `'a` å¼•ç”¨ï¼Œå› ä¸º Rust ä¼šè‡ªåŠ¨æŠŠ `'static` å¼•ç”¨å¼ºåˆ¶è½¬æ¢ä¸º `'a` å¼•ç”¨ã€‚ç›´è§‰ä¸Šè¿™å¾ˆåˆç†ï¼Œå› ä¸ºåœ¨ä¸€ä¸ªå¯¹ç”Ÿå‘½å‘¨æœŸè¦æ±‚æ¯”è¾ƒçŸ­çš„åœ°æ–¹ç”¨ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ¯”è¾ƒé•¿çš„å¼•ç”¨ç»ä¸ä¼šå¯¼è‡´ä»»ä½•å†…å­˜å®‰å…¨é—®é¢˜ã€‚ä¸‹é¢çš„è¿™æ®µä»£ç é€šè¿‡ç¼–è¯‘ï¼Œå’Œé¢„æœŸä¸€è‡´ï¼š

```rust
use rand;

fn generic_str_fn<'a>() -> &'a str {
    "str"
}

fn static_str_fn() -> &'static str {
    "str"
}

fn a_or_b<T>(a: T, b: T) -> T {
    if rand::random() {
        a
    } else {
        b
    }
}

fn main() {
    let some_string = "string".to_owned();
    let some_str = &some_string[..];
    let str_ref = a_or_b(some_str, generic_str_fn()); // ç¼–è¯‘é€šè¿‡
    let str_ref = a_or_b(some_str, static_str_fn()); // ç¼–è¯‘é€šè¿‡
}
```

ç„¶è€Œå½“å¼•ç”¨ä½œä¸ºå‡½æ•°ç±»å‹ç­¾åçš„ä¸€éƒ¨åˆ†æ—¶ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢å¹¶ä¸ç”Ÿæ•ˆã€‚æ‰€ä»¥ä¸‹é¢è¿™æ®µä»£ç ä¸èƒ½é€šè¿‡ç¼–è¯‘ï¼š

```rust
use rand;

fn generic_str_fn<'a>() -> &'a str {
    "str"
}

fn static_str_fn() -> &'static str {
    "str"
}

fn a_or_b_fn<T, F>(a: T, b_fn: F) -> T
    where F: Fn() -> T
{
    if rand::random() {
        a
    } else {
        b_fn()
    }
}

fn main() {
    let some_string = "string".to_owned();
    let some_str = &some_string[..];
    let str_ref = a_or_b_fn(some_str, generic_str_fn); // ç¼–è¯‘é€šè¿‡
    let str_ref = a_or_b_fn(some_str, static_str_fn); // ç¼–è¯‘é”™è¯¯
}
```

æŠ¥é”™å¦‚ä¸‹ï¼š

```rust
error[E0597]: `some_string` does not live long enough
  --> src/main.rs:23:21
   |
23 |     let some_str = &some_string[..];
   |                     ^^^^^^^^^^^ borrowed value does not live long enough
...
25 |     let str_ref = a_or_b_fn(some_str, static_str_fn);
   |                   ---------------------------------- argument requires that `some_string` is borrowed for `'static`
26 | }
   | - `some_string` dropped here while still borrowed
```

å¾ˆéš¾è¯´è¿™æ˜¯ä¸æ˜¯ Rust çš„ä¸€ä¸ªé™·é˜±ï¼ŒæŠŠ `for<T> Fn() -> &'static T` å¼ºåˆ¶è½¬æ¢æˆ `for<'a, T> Fn() -> &'a T` å¹¶ä¸æ˜¯ä¸€ä¸ªåƒæŠŠ `&'static str` å¼ºåˆ¶è½¬æ¢ä¸º `&'a str` è¿™æ ·ç®€å•ç›´ç™½çš„æƒ…å†µã€‚å‰è€…æ˜¯ç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œåè€…æ˜¯å€¼ä¹‹é—´çš„è½¬æ¢ã€‚

**å…³é”®ç‚¹å›é¡¾**
- `for <'aï¼ŒT> fnï¼ˆï¼‰->ï¼†'a T` ç­¾åçš„å‡½æ•°æ¯” `for <T> fnï¼ˆï¼‰->ï¼†'static T` ç­¾åçš„å‡½æ•°è¦æ›´çµæ´»ï¼Œå¹¶ä¸”æ³›ç”¨äºæ›´å¤šåœºæ™¯



## æ€»ç»“

- `T` æ˜¯ `&T` å’Œ `&mut T` çš„è¶…é›†
- `&T` å’Œ `&mut T` æ˜¯ä¸ç›¸äº¤çš„é›†åˆ
- `T: 'static` åº”å½“è§†ä¸º _â€œ`T` æ»¡è¶³ `'static` ç”Ÿå‘½å‘¨æœŸçº¦æŸâ€_
- è‹¥ `T: 'static` åˆ™ `T` å¯ä»¥æ˜¯ä¸€ä¸ªæœ‰ `'static` ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ç±»å‹ _æˆ–_ æ˜¯ä¸€ä¸ªæ‰€æœ‰æƒç±»å‹
- å› ä¸º `T: 'static` åŒ…æ‹¬äº†æ‰€æœ‰æƒç±»å‹ï¼Œæ‰€ä»¥ `T`
    - å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†é…
    - ä¸éœ€è¦åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´éƒ½æœ‰æ•ˆ
    - å¯ä»¥å®‰å…¨ï¼Œè‡ªç”±åœ°ä¿®æ”¹
    - å¯ä»¥åœ¨è¿è¡Œæ—¶è¢«åŠ¨æ€çš„ drop
    - å¯ä»¥æœ‰ä¸åŒé•¿åº¦çš„ç”Ÿå‘½å‘¨æœŸ
- `T: 'a` æ¯” `&'a T` æ›´æ³›åŒ–ï¼Œæ›´çµæ´»
- `T: 'a` æ¥å—æ‰€æœ‰æƒç±»å‹ï¼Œå†…éƒ¨å«æœ‰å¼•ç”¨çš„æ‰€æœ‰æƒç±»å‹ï¼Œå’Œå¼•ç”¨
- `&'a T` åªæ¥å—å¼•ç”¨
- è‹¥ `T: 'static` åˆ™ `T: 'a` å› ä¸ºå¯¹äºæ‰€æœ‰ `'a` éƒ½æœ‰ `'static` >= `'a`
- å‡ ä¹æ‰€æœ‰çš„ Rust ä»£ç éƒ½æ˜¯æ³›å‹ä»£ç ï¼Œå¹¶ä¸”åˆ°å¤„éƒ½å¸¦æœ‰è¢«çœç•¥æ‰çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸæ³¨è§£e
- Rust ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™å¹¶ä¸ä¿è¯åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½æ­£ç¡®
- åœ¨ç¨‹åºçš„è¯­ä¹‰æ–¹é¢ï¼ŒRust å¹¶ä¸æ¯”ä½ æ‡‚
- å¯ä»¥è¯•è¯•ç»™ä½ çš„ç”Ÿå‘½å‘¨æœŸæ³¨è§£èµ·ä¸€ä¸ªæœ‰æ„ä¹‰çš„åå­—
- è¯•ç€è®°ä½ä½ åœ¨å“ªé‡Œæ·»åŠ äº†æ˜¾å¼ç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼Œä»¥åŠä¸ºä»€ä¹ˆè¦
- æ‰€æœ‰ trait å¯¹è±¡éƒ½å«æœ‰è‡ªåŠ¨æ¨å¯¼çš„ç”Ÿå‘½å‘¨æœŸ
- Rust ç¼–è¯‘é”™è¯¯çš„æç¤ºä¿¡æ¯æ‰€æå‡ºçš„ä¿®å¤æ–¹æ¡ˆå¹¶ä¸ä¸€å®šèƒ½æ»¡è¶³ä½ å¯¹ç¨‹åºçš„éœ€æ±‚
- ç”Ÿå‘½å‘¨æœŸåœ¨ç¼–è¯‘æ—¶è¢«é™æ€ç¡®å®š
- ç”Ÿå‘½å‘¨æœŸåœ¨è¿è¡Œæ—¶ä¸èƒ½è¢«æ”¹å˜
- Rust å€Ÿç”¨æ£€æŸ¥å™¨å‡è®¾æ‰€æœ‰ä»£ç è·¯å¾„éƒ½èƒ½è¢«æ‰§è¡Œï¼Œæ‰€ä»¥æ€»æ˜¯é€‰æ‹©å°½å¯èƒ½çŸ­çš„ç”Ÿå‘½å‘¨æœŸèµ‹ç»™å˜é‡
- å°½é‡é¿å…é‡å€Ÿç”¨ä¸€ä¸ªç‹¬å å¼•ç”¨ä¸ºå…±äº«å¼•ç”¨ï¼Œä¸ç„¶ä½ ä¼šé‡åˆ°å¾ˆå¤šéº»çƒ¦
- é‡å€Ÿç”¨ä¸€ä¸ªç‹¬å å¼•ç”¨å¹¶ä¸ä¼šç»“æŸå…¶ç”Ÿå‘½å‘¨æœŸï¼Œå“ªæ€•å®ƒè‡ªèº«å·²ç»è¢« drop æ‰äº†
- æ¯ä¸ªè¯­è¨€éƒ½æœ‰å…¶é™·é˜± ğŸ¤·
- `for <'aï¼ŒT> fnï¼ˆï¼‰->ï¼†'a T` ç­¾åçš„å‡½æ•°æ¯” `for <T> fnï¼ˆï¼‰->ï¼†'static T` ç­¾åçš„å‡½æ•°è¦æ›´çµæ´»ï¼Œå¹¶ä¸”æ³›ç”¨äºæ›´å¤šåœº



## è®¨è®º

å¯ä»¥åœ¨è¿™äº›åœ°æ–¹è¿›è¡Œè®¨è®º
- [learnrust subreddit](https://www.reddit.com/r/learnrust/comments/gmrcrq/common_rust_lifetime_misconceptions/)
- [official Rust users forum](https://users.rust-lang.org/t/blog-post-common-rust-lifetime-misconceptions/42950)
- [Twitter](https://twitter.com/pretzelhammer/status/1263505856903163910)
- [rust subreddit](https://www.reddit.com/r/rust/comments/golrsx/common_rust_lifetime_misconceptions/)
- [Hackernews](https://news.ycombinator.com/item?id=23279731)
- [Github](https://github.com/pretzelhammer/rust-blog/discussions)



## æ¸©é¦¨æç¤º

é€šè¿‡è¿™äº›æ¸ é“è·å–æœ€æ–°æ¶ˆæ¯
- [Following pretzelhammer on Twitter](https://twitter.com/pretzelhammer) or
- Watching this repo's releases (click on `Watch` dropdown and select `Releases only`)



## æ‹“å±•é˜…è¯»

- [Sizedness in Rust](./sizedness-in-rust.md)
- [Learning Rust in 2020](./learning-rust-in-2020.md)
- [Learn Assembly with Entirely Too Many Brainfuck Compilers](./too-many-brainfuck-compilers.md)

## è¯‘è€…æ³¨

æœ¬æ–‡å‚è€ƒäº†
- [whfuyn çš„è¯‘æ–‡](https://github.com/whfuyn/rust-blog/blob/master/posts/Rustç”Ÿå‘½å‘¨æœŸçš„å¸¸è§è¯¯è§£.md)
- [Rust è¯­è¨€æœ¯è¯­ä¸­è‹±æ–‡å¯¹ç…§è¡¨](https://rustwiki.org/zh-CN/rust-wiki/translate/english-chinese-glossary-of-rust.html)
- [The book ä¸­æ–‡ç‰ˆ](https://kaisery.github.io/trpl-zh-cn/)

æ–‡ä¸­éƒ¨åˆ†è¯­å¥é‡‡ç”¨æ„è¯‘ï¼Œéƒ¨åˆ†å•è¯ä¸è¯‘ã€‚
